{"id":"Spoofing the {source.Name} Process","inclusions":{"loadedInclusions":[{"source":"Process","target":"Process","requiresTrustBoundaryIntersection":true},{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{"implements or uses Authentication Mechanism":"yes"},"flowExclusionAttributes":{"authenticates source":"yes"},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{source.Name} may be spoofed by an attacker and this may lead to unauthorized access to {targetName}. Consider using a standard authentication mechanism to identify the source process.","titleTemplate":"Spoofing the {source.Name} Process","strideCategory":"SPOOFING"}
{"id":"Insufficient Auditing","inclusions":{"loadedInclusions":[{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Does the log capture enough data to understand what happened in the past? Do your logs capture enough data to understand an incident after the fact? Is such capture lightweight enough to be left on all the time? Do you have enough data to deal with repudiation claims? Make sure you log sufficient and appropriate data to handle a repudiation claims. You might want to talk to an audit expert as well as a privacy expert about your choice of data.","titleTemplate":"Insufficient Auditing","strideCategory":"REPUDIATION"}
{"id":"Potential Weak Protections for Audit Data","inclusions":{"loadedInclusions":[{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Consider what happens when the audit mechanism comes under attack, including attempts to destroy the logs, or attack log analysis programs. Ensure access to the log is through a reference monitor, which controls read and write separately. Document what filters, if any, readers can rely on, or writers should expect","titleTemplate":"Potential Weak Protections for Audit Data","strideCategory":"REPUDIATION"}
{"id":"Potential Data Repudiation by {target.Name}","inclusions":{"loadedInclusions":[{"source":"","target":"Process","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{target.Name} claims that it did not receive data from a source outside the trust boundary. Consider using logging or auditing to record the source, time, and summary of the received data.","titleTemplate":"Potential Data Repudiation by {target.Name}","strideCategory":"REPUDIATION"}
{"id":"External Entity {target.Name} Potentially Denies Receiving Data","inclusions":{"loadedInclusions":[{"source":"","target":"External Entity","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{target.Name} claims that it did not receive data from a source outside the trust boundary. Consider using logging or auditing to record the source, time, and summary of the received data.","titleTemplate":"Potential Data Repudiation by {target.Name}","strideCategory":"REPUDIATION"}
{"id":"Data Store Denies {target.Name} Potentially Writing Data","inclusions":{"loadedInclusions":[{"source":"","target":"Data Store","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{target.Name} claims that it did not write data received from an entity on the other side of the trust boundary. Consider using logging or auditing to record the source, time, and summary of the received data.","titleTemplate":"Data Store Denies {target.Name} Potentially Writing Data","strideCategory":"REPUDIATION"}
{"id":"Authorization Bypass","inclusions":{"loadedInclusions":[{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Can you access {target.Name} and bypass the permissions for the object? For example by editing the files directly with a hex editor, or reaching it via filesharing? Ensure that your program is the only one that can access the data, and that all other subjects have to use your interface.","titleTemplate":"Authorization Bypass","strideCategory":"INFORMATION_DISCLOSURE"}
{"id":"Data Flow Sniffing","inclusions":{"loadedInclusions":[{"source":"Process","target":"Process","requiresTrustBoundaryIntersection":true},{"source":"External Entity","target":"Process","requiresTrustBoundaryIntersection":true},{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{"provides confidentiality":"yes"},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Data flowing across {flow.Name} may be sniffed by an attacker. Depending on what type of data an attacker can read, it may be used to attack other parts of the system or simply be a disclosure of information leading to compliance violations. Consider encrypting the data flow.","titleTemplate":"Data Flow Sniffing","strideCategory":"INFORMATION_DISCLOSURE"}
{"id":"Weak Access Control for a Resource","inclusions":{"loadedInclusions":[{"source":"Data Store","target":"Process","requiresTrustBoundaryIntersection":false},{"source":"Data Store","target":"External Entity","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Improper data protection of {source.name} can allow an attacker to read information not intended for disclosure. Review authorization settings.","titleTemplate":"Weak Access Control for a Resource","strideCategory":"INFORMATION_DISCLOSURE"}
{"id":"Weak Credential Storage","inclusions":{"loadedInclusions":[{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Credentials held at the server are often disclosed or tampered with and credentials stored on the client are often stolen. For server side, consider storing a salted hash of the credentials instead of storing the credentials themselves. If this is not possible due to business requirements, be sure to encrypt the credentials before storage, using an SDL-approved mechanism. For client side, if storing credentials is required, encrypt them and protect the data store in which they're stored","titleTemplate":"Weak Credential Storage","strideCategory":"INFORMATION_DISCLOSURE"}
{"id":"Weak Credential Transit","inclusions":{"loadedInclusions":[{"source":"Process","target":"Process","requiresTrustBoundaryIntersection":true},{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{"flow is HTTPS":"yes","flow is IPsec":"yes"},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Credentials on the wire are often subject to sniffing by an attacker. Are the credentials re-usable/re-playable? Are credentials included in a message? For example, sending a zip file with the password in the email. Use strong cryptography for the transmission of credentials. Use the OS libraries if at all possible, and consider cryptographic algorithm agility, rather than hardcoding a choice.","titleTemplate":"Weak Credential Transit","strideCategory":"INFORMATION_DISCLOSURE"}
{"id":"Weak Authentication Scheme","inclusions":{"loadedInclusions":[{"source":"Process","target":"Process","requiresTrustBoundaryIntersection":false},{"source":"","target":"","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Custom authentication schemes are susceptible to common weaknesses such as weak credential change management, credential equivalence, easily guessable credentials, null credentials, downgrade authentication or a weak credential change management system. Consider the impact and potential mitigations for your custom authentication scheme.","titleTemplate":"Weak Authentication Scheme","strideCategory":"INFORMATION_DISCLOSURE"}
{"id":"Potential Excessive Resource Consumption for {source.Name} or {target.Name}","inclusions":{"loadedInclusions":[{"source":"Process","target":"Data Store","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Does {source.Name} or {target.Name} take explicit steps to control resource consumption? Resource consumption attacks can be hard to deal with, and there are times that it makes sense to let the OS do the job. Be careful that your resource requests don't deadlock, and that they do timeout.","titleTemplate":"Potential Excessive Resource Consumption for {source.Name} or {target.Name}","strideCategory":"DENIAL_OF_SERVICE"}
{"id":"Potential Process Crash or Stop for {target.Name}","inclusions":{"loadedInclusions":[{"source":"","target":"Process","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{target.Name} crashes, halts, stops or runs slowly; in all cases violating an availability metric.","titleTemplate":"Potential Process Crash or Stop for {target.Name}","strideCategory":"DENIAL_OF_SERVICE"}
{"id":"Data Flow {flow.Name} Is Potentially Interrupted","inclusions":{"loadedInclusions":[{"source":"","target":"","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"An external agent interrupts data flowing across a trust boundary in either direction.","titleTemplate":"Data Flow {flow.Name} Is Potentially Interrupted","strideCategory":"DENIAL_OF_SERVICE"}
{"id":"Data Store Inaccessible","inclusions":{"loadedInclusions":[{"source":"Data Store","target":"Data Store","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"An external agent prevents access to a data store on the other side of the trust boundary.","titleTemplate":"Data Store Inaccessible","strideCategory":"DENIAL_OF_SERVICE"}
{"id":"Weakness in SSO Authorization","inclusions":{"loadedInclusions":[{"source":"Weakness in SSO Authorization","target":"","requiresTrustBoundaryIntersection":false},{"source":"","target":"","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Common SSO implementations such as OAUTH2 and OAUTH Wrap are vulnerable to MitM attacks.","titleTemplate":"Weakness in SSO Authorization","strideCategory":"ELEVATION_OF_PRIVILEGE"}
{"id":"Elevation Using Impersonation","inclusions":{"loadedInclusions":[{"source":"External Entity","target":"Process","requiresTrustBoundaryIntersection":false},{"source":"Process","target":"Process","requiresTrustBoundaryIntersection":false}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{target.Name} may be able to impersonate the context of {source.Name} in order to gain additional privilege.","titleTemplate":"Elevation Using Impersonation","strideCategory":"ELEVATION_OF_PRIVILEGE"}
{"id":"{target.Name} May be Subject to Elevation of Privilege Using Remote Code Execution","inclusions":{"loadedInclusions":[{"source":"","target":"Procses","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"{source.Name} may be able to remotely execute code for {target.Name}.","titleTemplate":"{target.Name} May be Subject to Elevation of Privilege Using Remote Code Execution","strideCategory":"ELEVATION_OF_PRIVILEGE"}
{"id":"Elevation by Changing the Execution Flow in {target.Name}","inclusions":{"loadedInclusions":[{"source":"","target":"Process","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"An attacker may pass data into {target.Name} in order to change the flow of program execution within {target.Name} to the attacker's choosing.","titleTemplate":"Elevation by Changing the Execution Flow in {target.Name}","strideCategory":"ELEVATION_OF_PRIVILEGE"}
{"id":"Cross Site Request Forgery","inclusions":{"loadedInclusions":[{"source":"Process","target":"Process","requiresTrustBoundaryIntersection":true},{"source":"External Entity","target":"Process","requiresTrustBoundaryIntersection":true}]},"exclusions":{"loadedExclusions":[{"source":"","target":"","sourceExclusionAttributes":{},"flowExclusionAttributes":{},"targetExclusionAttributes":{}}]},"descriptionTemplate":"Cross-site request forgery (CSRF or XSRF) is a type of attack in which an attacker forces a user's browser to make a forged request to a vulnerable site by exploiting an existing trust relationship between the browser and the vulnerable web site.  In a simple scenario, a user is logged in to web site A using a cookie as a credential.  The other browses to web site B.  Web site B returns a page with a hidden form that posts to web site A.  Since the browser will carry the user's cookie to web site A, web site B now can take any action on web site A, for example, adding an admin to an account.  The attack can be used to exploit any requests that the browser automatically authenticates, e.g. by session cookie, integrated authentication, IP whitelisting.  The attack can be carried out in many ways such as by luring the victim to a site under control of the attacker, getting the user to click a link in a phishing email, or hacking a reputable web site that the victim will visit. The issue can only be resolved on the server side by requiring that all authenticated state-changing requests include an additional piece of secret payload (canary or CSRF token) which is known only to the legitimate web site and the browser and which is protected in transit through SSL/TLS. See the Forgery Protection property on the flow stencil for a list of mitigations.","titleTemplate":"Cross Site Request Forgery","strideCategory":"ELEVATION_OF_PRIVILEGE"}
